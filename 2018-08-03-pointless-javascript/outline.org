* Intro
** Who am I
** My contact information
* Other title 
** Point Free JavaScript
** elevating the readability of JavaScript using functional composition, partial function application and currying....and without function parameters.
** mention other languages
** elevating the readability of JavaScript or Scala using functional composition, partial function application and currying....and without function parameters.
* Disclaimer
** I'm not sure coworkers have really taken to this
* What is Point Free programming
 ...it's tacit programming
* What is tacit programming
 ...writing function that don't deine arguments
** Example function
   const strikeOut = function(strikes) { return strikes === 3; };
   
   const strikeOut = equals(3)
   // strikeOut = Number -> Boolean
   
** Mention how we are going to remove the points and the code will be easier to read
   Small, multipurpose functions and build up more complex ones

* Example or _really_ bad JS
const ???????? = function(params) {
  const provided = []
  for(var key in params) {
    if(params[key] != undefined){
      provided.push(lib.encode(key) + "=" + lib.encode(params[key]))
    }
  }
  return provided.join("&")
}


* talk about lodash
*** https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore
    
https://lodash.com

* Example of better JS
  const ?????? = (params) => {
    const a = _.map(params, (v,k) => [k,v])
    const b = _.filter(a, ([k, v]) => ! _.isUndefined(v))
    const c = _.map(b, ([k, v]) => [lib.encode(k), lib.encode(v)])
    const d = _.map(c, (pair) => pair.join("="))
    return d.join("&")
  }

** Better even still with lodash
  const ?????? = (params) => {
    _.chain(params)
     .toPairs
     .filter(([k, v]) => ! _.isUndefined(v))
     .map(([k, v]) => [lib.encode(k), lib.encode(v)])
     .map((pair) => pair.join("="))
     .join("&")
     .value()
  }

  const querystringify = (params) => {
    _.chain(params)
     .toPairs
     .filter(([k, v]) => ! _.isUndefined(v))
     .map(([k, v]) => [lib.encode(k), lib.encode(v)])
     .map((pair) => pair.join("="))
     .join("&")
     .value()
  }

* Example of how we think about it
*** Write out the steps
  querystringify
    remove missing parameters
    encode the keys and values
    join keys and values with equals
    join the parameters with ampersand

*** give it a name
  querystringify = pipe(
    remove missing parameters,
    encode the keys and values,
    join keys and values with equals, 
    join the parameters with ampersand
  )

*** give it a name
  querystringify = pipe(
    removeMissingParameters,
    encodeTheKeysAndValues,
    joinKeysAndValuesWithEquals, 
    joinParametersWithAmpersand
  )

* Quick explanation of functional composition
  pipe takes a functions f:x->y, g:y->z 
  return a new funtion that x->z

  return g(f(x))
  
*** give it a name
  const querystringify = pipe(
    removeMissingParameters,
    encodeTheKeysAndValues,
    joinKeysAndValuesWithEquals,
    joinParametersWithAmpersand
  )


* Show how pipe works
---maybe no

** basically a reduce over a collection of functions
   [f,g,h].reduce...

* show it in other languages
  bash
  
  ps -ef | grep java | awk '{print $2}' | kill
  
  scala
  
    val queryStringify = 
      removeMissingParameters
        .andThen(encodeTheKeysAndValues)
        .andThen(joinKeysAndValuesWithEquals)
        .andThen(joinParametersWithAmpersand)
    
    methods vs function

  
  elixir
  "Elixir rocks" |> 
  String.upcase() |> 
  String.split()
  
* pipe vs compose

  pipe(a,b,c) = c(b(a(x)))
  
  compose(a,b,c) = a(b(c(x)))
  
  depends on how you think
  pipe = the steps I'm taking
  pipe(step1, step2, step3)

  compose = reads more like english
  compose(top5, nationalLeague, cathers)
  
  typically pick up one and stick with it
  

* review where we left it

*** give it a name

  const querystringify = pipe(
    removeMissingParameters,
    encodeTheKeysAndValues,
    joinKeysAndValuesWithEquals,
    joinParametersWithAmpersand
  )

*** better naems

  const querystringify = pipe(
    removeMissing,
    encodeTheKeysAndValues,
    joinKeysAndValuesWithEquals, 
    joinParametersWithAmpersand
  )

  const querystringify = pipe(
    removeMissing,
    encode,
    joinKeysAndValuesWithEquals, 
    joinParametersWithAmpersand
  )

  const querystringify = pipe(
    removeMissing,
    encode,
    joinEquals,
    joinAmpersand,
  )

* spoon on the curry

* A quick explanation of curry
  A function that returns another funcion
  
  const join = function(j){
    return function(list) {
      return list.join(j);
    }
  }
  
  const join = j => list => list.join(j)
  
* lodash curry

  const fancy = _.curry((j,list) => list.join(j))
  fancy("-") // [Function]
  fancy("-", [1,2,3]) // String: '1-2-3'

* limitations with lodash curry
  only fixed arity function

* show it in other languages
  def join(j: String)(list: Seq[String]) = list.mkString(j)
  
  val join = (j:String) => (list:Seq[String]) = list.mkString(j)

  val join = ((j:String, list:Seq[String]) = list.mkString(j)).curried
  
  val join = (_:Seq[String]).mkString(_:String)
  

* show how we use it
  const join = j => list => list.join(j)

  const querystringify = pipe(
    removeMissing,
    encode,
    join("="),
    join("&")
  )


* talk about how this all available in lodash
  
  _.join(array, [separator=','])
  
* two problems

1 data comes first
2 varargs makes it hard to query

* lodash fp

fp button

https://github.com/lodash/lodash/wiki/FP-Guide

* talk about lodash fp 
  data last
  fixed arity ... no variadic 
  fixed arity spawns aliases
  
* need two things
  const pipe = require('lodash/fp/pipe')
  const join = require('lodash/fp/join')
  
* 
  const pipe = require('lodash/fp/pipe')
  const join = require('lodash/fp/join')

  const querystringify = pipe(
    removeMissing,
    encode,
    join("="), 
    join("&")
  )

* ....add array to avoid var args
  const {pipe, join} = require('lodash/fp')

  const querystringify = pipe([
    removeMissing,
    encode,
    join("="),
    join("&")
  ])

* ....add array to avoid var args
  const fp = require('lodash/fp')

  const querystringify = fp.pipe([
    removeMissing,
    encode,
    fp.join("="),
    fp.join("&")
  ])

* ....add array to avoid var args

  const removeMissing = fp.pipe([
    fp.pairs, 
    fp.filter(([k,v]) => ! fp.isUndefined(v))
  ])
  
  const querystringify = fp.pipe([
    removeMissing,
    encode,
    fp.join("="),
    fp.join("&")
  ])

* Maybe too far

  const removeMissing = fp.pipe([
    fp.pairs, 
    fp.filter(
      fp.negate(
        fp.pipe(
          fp.at(1),
          fp.isUndefined)))
  ])
  
  const querystringify = fp.pipe([
    removeMissing,
    encode,
    fp.join("="),
    fp.join("&")
  ])

* Give it a name
  
  const valueIsUndefined = fp.pipe(
                            fp.at(1),
                            fp.isUndefined))

  const removeMissing = fp.pipe([
    fp.pairs, 
    fp.filter(
      fp.negate(valueIsUndefined))
  ])
  
  const querystringify = fp.pipe([
    removeMissing,
    encode,
    fp.join("="),
    fp.join("&")
  ])
  
* Event simpler

  const removeMissing = fp.pickBy(fp.negate(fp.isUndefined))
  
  const querystringify = fp.pipe([
    removeMissing,
    encode,
    fp.join("="),
    fp.join("&")
  ])

* Deal with encode

  const encode = fp.map((v, k) => [lib.urlEncode(k), lib.urlEncode(v)]) 
  
  const querystringify = fp.pipe([
    removeMissing,
    encode,
    fp.join("="),
    fp.join("&")
  ])

* Deal with encode

  const encode = fp.pipe(
                   fp.toPairs,
                   fp.map(
                    fp.map(lib.urlEncode)))
  
  const querystringify = fp.pipe([
    removeMissing,
    encode,
    fp.join("="),
    fp.join("&")
  ])
  
* Review all

  const removeMissing = fp.pickBy(fp.negate(fp.isUndefined))

  const encode = fp.pipe(
                   fp.toPairs,
                   fp.map(
                    fp.map(lib.urlEncode)))
  
  const querystringify = fp.pipe([
    removeMissing,
    encode,
    fp.join("="),
    fp.join("&")
  ])

* Review all

  const removeMissing = pickBy(fp.negate(fp.isUndefined))

  const encode = pipe(
                   toPairs,
                   map(
                    map(lib.urlEncode)))
  
  const querystringify = fp.pipe([
    removeMissing,
    encode,
    join("="),
    join("&")
  ])

* show some of the other lodash fp things
  fp.cond([
    [predicateFunction, applicativeFunction], 
    [ (x => x < 0), (x) => console.log(x, "is less than zero")], 
    [ fp.equals(0), someOtherFunction ], 
    [ fp.T,         thisIsTheDefaultFunction ]
  ])

* show some of the other lodash fp things
  const isAction = name => (action, state) => name === action
  const incrementCount = (action, state) => state + 1

  export default = fp.cond([
    [isAction("CLICK_UP"),   incrementCount], 
    [isAction("CLICK_DOWN"), decrementCount], 
    [fp.T,                   previousState ]
  ])
  

* show partial function application
  
 _ placeholder in lodash 
 
 const f = fp.curry((a,b,c,d) => console.log({a,b,c,d}))

 > f(1,2,3,4)
 { a: 1, b: 2, c: 3, d: 4 }
 
 const g = f(1, fp.__, 3, fp.__)
 
 > g('b', 'd')
 { a: 1, b: 'b', c: 3, d: 'd' }

* show the example in scala
  val f = doSomething(1, _, 2)

* talk about ramda

* show a bit of the rambda things
* talk about sanctuary
* talk about trade offs
* show debugging trick
  fp.pipe(
    doSomething, 
    fp.tap(debugger),
    otherThing)
   
  
* mention to use this when you want...not always
* questions
